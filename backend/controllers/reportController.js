import { medicalContract } from "../services/blockchain.js";
import { uploadToIPFS, calculateFileHash } from "../services/ipfs.js";
import { analyzeXray } from "../services/aiService.js";

// Optional: If you decided on a DB (Firebase/Postgres), import it here
// import { db } from "../config/db.js"; 

export const reportController = {

    /**
     * 1. Submit a New Medical Report
     * Flow: Front-end sends File + Data -> Server hashes File -> Uploads to IPFS -> Writes to Blockchain
     */
    submitMedicalReport: async (req, res) => {
        try {
            // Check if file exists in request (handled by middleware like Multer)
            if (!req.file) {
                return res.status(400).json({ error: "No certificate file provided" });
            }

            const { patientName, patientId, diseaseType } = req.body;
            const fileBuffer = req.file.buffer;
            const fileName = req.file.originalname;

            console.log(`Processing report for: ${patientName}`);

            // A. Generate the Content Hash (The fingerprint)
            const contentHash = calculateFileHash(fileBuffer);
            console.log("Generated Hash:", contentHash);

            // ML ANALYSIS
            // We analyze the image to get a prediction
            let mlPrediction = "Unknown";
            let mlConfidence = 0;
            try {
                console.log("Analzying file with ML Model...");
                const analysis = await analyzeXray(fileBuffer);
                mlPrediction = analysis.condition || analysis.disease || "Unknown";
                mlConfidence = analysis.confidence || 0;
                console.log(`ðŸ¤– ML Prediction: ${mlPrediction} (${mlConfidence})`);
            } catch (err) {
                console.warn("âš ï¸ ML Analysis failed, proceeding with manual entry:", err.message);
            }

            // B. Upload to IPFS
            const ipfsHash = await uploadToIPFS(fileBuffer, fileName);
            console.log("IPFS CID:", ipfsHash);

            // C. Write to Blockchain
            // Assuming we might want to store the ML result on chain if the contract supported it, 
            // but for now we just use the user provided `diseaseType` or we could override it?
            // Let's stick to the user input `diseaseType` for the contract to be safe, 
            // but return the ML result in the response.

            console.log("Sending transaction to blockchain...");
            const tx = await medicalContract.addReport(
                patientId,
                ipfsHash,
                contentHash,
                diseaseType
            );

            // Wait for the transaction to be mined
            const receipt = await tx.wait();

            // D. (Optional) Save metadata to local DB (Firebase/Postgres) for faster searching later
            // await db.collection('reports').add({ patientId, ipfsHash, txHash: receipt.hash });

            res.status(201).json({
                success: true,
                message: "Medical report minted successfully",
                data: {
                    transactionHash: receipt.hash, // The proof on blockchain
                    ipfsHash: ipfsHash,            // The link to the file
                    reportId: contentHash          // Or the ID generated by your contract
                }
            });

        } catch (error) {
            console.error("Submission Error:", error);
            res.status(500).json({
                success: false,
                error: error.message || "Failed to submit report"
            });
        }
    },

    /**
     * 2. Validate/Verify a Certificate
     * Flow: User uploads a file -> We hash it -> We check if that hash exists in the Smart Contract
     */
    validateCertificate: async (req, res) => {
        try {
            if (!req.file) {
                return res.status(400).json({ error: "Please upload the document to verify" });
            }

            const { reportId } = req.body; // If your contract uses an ID to find reports
            const fileBuffer = req.file.buffer;

            // A. Calculate Hash of the uploaded document
            const calculatedHash = calculateFileHash(fileBuffer);

            // B. Fetch the stored hash from the Blockchain
            // Assuming contract has a view function: getReportHash(reportId) or similar
            const storedReport = await medicalContract.getReport(reportId);

            // Note: Solidity returns data arrays/structs. You might need storedReport.contentHash or storedReport[2]
            const storedHash = storedReport.contentHash || storedReport[2];
            const isRepudiated = storedReport.isRepudiated || storedReport[4]; // Check validation status

            // C. Compare
            const isValid = (storedHash === calculatedHash);

            if (!isValid) {
                return res.status(200).json({
                    valid: false,
                    message: "Document hash mismatch! This file may have been tampered with."
                });
            }

            if (isRepudiated) {
                return res.status(200).json({
                    valid: false,
                    message: "This certificate was authentic but has been REPUDIATED (Revoked) by the authority."
                });
            }

            res.status(200).json({
                valid: true,
                message: "Certificate is Authentic and Active.",
                meta: {
                    patient: storedReport.patientName, // if available
                    timestamp: storedReport.timestamp // if available
                }
            });

        } catch (error) {
            console.error("Validation Error:", error);
            res.status(500).json({ error: "Validation failed on blockchain" });
        }
    },

    /**
     * 3. Repudiate (Revoke) a Disease Claim
     * Flow: Admin sends ID -> Contract updates status
     */
    repudiateDisease: async (req, res) => {
        try {
            const { subject, index, reason } = req.body;

            if (!subject || index === undefined || !reason) {
                return res.status(400).json({ error: "Subject, Index, and Reason are required" });
            }

            console.log(`Repudiating report for ${subject} at index ${index} for reason: ${reason}`);

            // Call the smart contract function
            const tx = await medicalContract.repudiateReport(subject, index, reason);

            await tx.wait();

            res.status(200).json({
                success: true,
                message: "Disease claim repudiated successfully on-chain."
            });

        } catch (error) {
            console.error("Repudiation Error:", error);
            res.status(500).json({ error: error.reason || error.message });
        }
    }
};